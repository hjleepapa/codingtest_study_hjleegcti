# 2nd Study : basic data structures

---

## 1. List

### **Q1. ë¦¬ìŠ¤íŠ¸ì˜ ê¸°ë³¸ ê°œë…**

### - ë¦¬ìŠ¤íŠ¸ì˜ ì—­ì‚¬

ë¦¬ìŠ¤íŠ¸ëŠ” ì»´í“¨í„° ê³¼í•™ì˜ ì´ˆê¸°ë¶€í„° ì‚¬ìš©ëœ ê¸°ë³¸ì ì¸ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. 1958ë…„ MITì˜ ì¡´ ë§¤ì¹´ì‹œê°€ ê°œë°œí•œ LISP $_{(1)}$ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œ ë¦¬ìŠ¤íŠ¸ê°€ ì¤‘ìš”í•œ ìë£Œêµ¬ì¡°ë¡œ ì‚¬ìš©ë˜ë©´ì„œ ë„ë¦¬ ì•Œë ¤ì§€ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

ë¦¬ìŠ¤íŠ¸ì˜ ì£¼ìš” íŠ¹ì§• ì¤‘ í•˜ë‚˜ëŠ” ì‚½ì…ê³¼ ì‚­ì œ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ì…ë‹ˆë‹¤. ë¦¬ìŠ¤íŠ¸ì˜ ë§¨ ì•ì´ë‚˜ ì¤‘ê°„ì— ë°ì´í„°ë¥¼ ì‚½ì…í•˜ê±°ë‚˜ ì‚­ì œí•  ë•Œ, ì¼ë°˜ì ìœ¼ë¡œ ìµœì•…ì˜ ê²½ìš° ì‹œê°„ ë³µì¡ë„ëŠ” O(n)ì…ë‹ˆë‹¤. ì´ëŠ” ìµœì•…ì˜ ê²½ìš° ë¦¬ìŠ¤íŠ¸ì˜ ê¸¸ì´ì— ë”°ë¼ ë” ë§ì€ ì—°ì‚°ì„ í•„ìš”ë¡œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì™œ ê·¸ë ‡ê²Œ ì‹œê°„ì´ ê±¸ë¦¬ëŠ”ì§€ ê°„ë‹¨íˆ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤. 

### Q2. ë¦¬ìŠ¤íŠ¸ ì‚½ì…/ì‚­ì œ ì‹œê°„ë³µì¡ë„ê°€ ì™œ O(n)ì¼ê¹Œ?

SLLë„ ê·¼ë³¸ì ì¸ ì›ë¦¬ëŠ” ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤. ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸(DLL)ì— ë¹„í•´ ì•½ê°„ì˜ ì—°ì‚°ê³¼ ë©”ëª¨ë¦¬ë¥¼ ë” ì“¸ ë¿ì´ì§€ í¬ê²Œ O(n)ëŠ” ë³€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ DLL ê¸°ì¤€ìœ¼ë¡œ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤. 

- ì‚½ì… ì‹œ: ì£¼ì–´ì§„ ìœ„ì¹˜ì— ìƒˆë¡œìš´ ì›ì†Œë¥¼ ì‚½ì…í•˜ë ¤ë©´ ì£¼ì–´ì§„ ìœ„ì¹˜ê¹Œì§€ ì ‘ê·¼í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ë˜ì„œ ìµœì•…ì˜ ê²½ìš° O(n)ì…ë‹ˆë‹¤. ë¬¼ë¡ , O(n/2)ì´ ì¢€ ë” ì •í™•í•˜ì§€ë§Œ ê·¼ì‚¬ì ìœ¼ë¡œ, O(n/2) = O(n)ì´ë¯€ë¡œ, O(n)ì…ë‹ˆë‹¤.
- ì‚­ì œ ì‹œ: ì›ì†Œë¥¼ ì‚­ì œí•œ í›„ ëª¨ë“  ìš”ì†Œë¥¼ í•œ ì¹¸ì”© ì•ìœ¼ë¡œ ë‹¹ê²¨ì•¼ í•©ë‹ˆë‹¤. ì´ ê²½ìš°ë„ ë§ˆì°¬ê°€ì§€ë¡œ O(n)ì…ë‹ˆë‹¤.

 

ë”°ë¼ì„œ ë¦¬ìŠ¤íŠ¸ëŠ” ì›ì†Œë¥¼ ì‚­ì œí•˜ê±°ë‚˜ ìƒˆë¡œ ì‚½ì…í•  ë•Œ O(n)ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§€ê²Œ ë©ë‹ˆë‹¤. ë¦¬ìŠ¤íŠ¸ì˜ ëì—ì„œë§Œ ë°ì´í„°ë¥¼ ì‚­ì œí•œë‹¤ë©´, ë‹¨ì¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸(SLL)ë‚˜ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸(DLL)ë¥¼ ì´ìš©í•´ì„œ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì¤‘ê°„ì— ë°ì´í„°ë¥¼ ìì£¼ ì‚½ì…í•˜ê±°ë‚˜ ì‚­ì œí•´ì•¼ í•˜ëŠ” ê²½ìš°ì—ëŠ” ë¦¬ìŠ¤íŠ¸ë³´ë‹¤ ë” íš¨ìœ¨ì ì¸ ìë£Œêµ¬ì¡°ë¥¼ ìƒí™©ì— ë§ê²Œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. (e.x. ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë‚˜, ìµœëŒ“ê°’ë§Œ ë³´ëŠ” ê²½ìš°ëŠ” í™ êµ¬ì¡°)

### Q3. ë¦¬ìŠ¤íŠ¸ì˜ íš¨ìœ¨ì„±

- ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸(DLL)ë¡œ êµ¬í˜„ëœ ë¦¬ìŠ¤íŠ¸ì˜ ê²½ìš°, ì œì¼ ì™¼ìª½ê³¼ ì œì¼ ì˜¤ë¥¸ìª½ì—ì„œ ì‚­ì œí•˜ëŠ” ê²½ìš° O(1)ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì¤‘ê°„ì— ìˆëŠ” ì›ì†Œë¥¼ ì‚­ì œí•˜ëŠ” ê²½ìš°ëŠ” O(n)ì´ ë©ë‹ˆë‹¤. ì´ëŠ” ë‹¨ì¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸(SLL)ì—ì„œë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤.

ì•„ë˜ëŠ” íŒŒì´ì¬ìœ¼ë¡œ êµ¬í˜„í•œ DLLì…ë‹ˆë‹¤. 

```python
class Node: # node ì •ì˜ 
    def __init__(self, num, prev=None, nxt=None):
        self.num = num
        self.prev = prev
        self.nxt = nxt

class Dll: # Doubly linked list 
    def __init__(self, lst=None):
        self.head = None
        self.tail = None
        if lst is not None:
            for num in lst:
                self.insert_tail(num)

    def insert_tail(self, num): # tailì— ë„£ê¸° 
        new_node = Node(num)
        if not self.tail:
            # ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆì„ ë•Œ
            self.head = new_node
            self.tail = new_node
        else:
            # ë¦¬ìŠ¤íŠ¸ì— ë…¸ë“œê°€ ìˆì„ ë•Œ
            new_node.prev = self.tail
            self.tail.nxt = new_node
            self.tail = new_node

    def insert_head(self, num): # headì— ë„£ê¸° 
        new_node = Node(num)
        if not self.head:
            # ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆì„ ë•Œ
            self.head = new_node
            self.tail = new_node
        else:
            # ë¦¬ìŠ¤íŠ¸ì— ë…¸ë“œê°€ ìˆì„ ë•Œ
            new_node.nxt = self.head
            self.head.prev = new_node
            self.head = new_node

    def delete_head(self): # head element ì§€ìš°ê¸° 
        if not self.head:
            return  # ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆìŒ
				
				# now it is not empty 
        if self.head == self.tail:
            # ë¦¬ìŠ¤íŠ¸ì— ë…¸ë“œê°€ í•˜ë‚˜ë§Œ ìˆì„ ë•Œ <=> head = tail 
            self.head = None
            self.tail = None
        else:
            # ë¦¬ìŠ¤íŠ¸ì— ë…¸ë“œê°€ ì—¬ëŸ¬ ê°œ ìˆì„ ë•Œ <=> head!=tail 
            self.head = self.head.nxt
            self.head.prev = None

    def delete_tail(self): # tailì„ ì§€ìš°ê¸° := head ë°©í–¥ ë°˜ëŒ€ë¡œ 
        if not self.tail:
            return 
            
        if self.tail == self.head:

            self.head = None
            self.tail = None
        else:
            # ë¦¬ìŠ¤íŠ¸ì— ë…¸ë“œê°€ ì—¬ëŸ¬ ê°œ ìˆì„ ë•Œ
            self.tail = self.tail.prev
            self.tail.nxt = None

    def __str__(self):
        # ë¦¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ë…¸ë“œë¥¼ ë¬¸ìì—´ë¡œ ë°˜í™˜
        current = self.head
        nodes = []
        while current != None:
            nodes.append(str(current.num))
            current = current.nxt
        return ' '.join(nodes)

```

- stack, queue, deque êµ¬í˜„

DLLì˜ tailì—ì„œ insert, delete ë©”ì†Œë“œë¥¼ ì´ìš©í•´ stackì„ êµ¬í˜„í•˜ê³ ,

DLLì˜ headì—ì„œ insert, delete ë©”ì†Œë“œë¥¼ ì´ìš©í•´ queueë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤. 

### 2. Tuple:

íŠœí”Œì˜ immutableí•œ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì¦‰ í•œë²ˆ ìƒì„±ëœ íŠœí”Œ ì¸ìŠ¤í„´ìŠ¤ ì•ˆì˜ ì •ë³´ëŠ” ë³€ê²½í•˜ê±°ë‚˜ ì‚­ì œë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ì„±ì§ˆ ë•ë¶„ì— hashableí•œ keyë¡œ ì´ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 

### Remark : Hash fucntion and Hashable?

ë‹¤ìŒì€ setê³¼ dictì…ë‹ˆë‹¤. setê³¼ dictionaryëŠ” hashë¡œ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ ë¨¼ì € hashê°€ ë¬´ì—‡ì¸ì§€ ì•Œì•„ë³´ê³ ì í•©ë‹ˆë‹¤. 

### **3.0 : í•´ì‹œ(Hash)ë€ ë¬´ì—‡ì¸ê°€?**

- **í•´ì‹œ í•¨ìˆ˜(Hash Function)**:
    - í•´ì‹œ í•¨ìˆ˜ëŠ” ì„ì˜ í¬ê¸°ì˜ ë°ì´í„°ë¥¼ ê³ ì •ëœ í¬ê¸°ì˜ ë°ì´í„°ë¡œ ë§¤í•‘í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤. $_{(4)}$ ì£¼ë¡œ ìˆ«ìë‚˜ ë¬¸ìì—´ ê°™ì€ ë°ì´í„°ë¥¼ ê³ ì •ëœ í¬ê¸°ì˜ ì •ìˆ˜(í•´ì‹œ ê°’)ë¡œ ë³€í™˜í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
    - ì „ì œì¡°ê±´:
        - **ì¼ê´€ì„±**: ë™ì¼í•œ ì…ë ¥ì— ëŒ€í•´ í•­ìƒ ë™ì¼í•œ ì¶œë ¥ì„ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤.
        - **íš¨ìœ¨ì„±**: í•´ì‹œ í•¨ìˆ˜ëŠ” ë§¤ìš° ë¹ ë¥´ê²Œ ê³„ì‚°í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
        - **ê· ë“± ë¶„í¬**: í•´ì‹œ ê°’ì´ ê³ ë¥´ê²Œ ë¶„í¬ë˜ì–´ì•¼ ì¶©ëŒì„ ìµœì†Œí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            
            ì¶©ëŒì´ë€ ì„œë¡œ ë‹¤ë¥¸ ëŒ€ìƒì´ ë™ì¼í•œ í‚¤ë¥¼ ê°€ì§ˆ ë•Œ key ì¶©ëŒì´ ì¼ì–´ë‚˜ëŠ” ê±¸ ë§í•©ë‹ˆë‹¤. 
            
- **í•´ì‹œ í…Œì´ë¸”(Hash Table)**:
    - í•´ì‹œ í…Œì´ë¸”ì€ ë°ì´í„°ë¥¼ ì €ì¥í•  ë•Œ í•´ì‹œ ê°’ì„ ì‚¬ìš©í•´ ë°ì´í„°ë¥¼ ë¹ ë¥´ê²Œ ê²€ìƒ‰í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì£¼ëŠ” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.
    - **êµ¬ì„±**:
        - **ë²„í‚·(Bucket)**: í•´ì‹œ ê°’ì— ì˜í•´ ê²°ì •ëœ ì¸ë±ìŠ¤ì— ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ê³µê°„.
        - **í•´ì‹œ í•¨ìˆ˜**: ë°ì´í„°ë¥¼ íŠ¹ì • ë²„í‚·ìœ¼ë¡œ ë§¤í•‘í•˜ê¸° ìœ„í•´ ì‚¬ìš©.
- **í•´ì‹œì˜ ì¥ì **:
    - í•´ì‹œ í…Œì´ë¸”ì„ ì‚¬ìš©í•˜ë©´ ë°ì´í„°ë¥¼ ë§¤ìš° ë¹ ë¥´ê²Œ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¼ë°˜ì ì¸ ê²½ìš°, ë°ì´í„°ì˜ ì‚½ì…, ì‚­ì œ, ê²€ìƒ‰ ì‹œê°„ì´ O(1)ë¡œ ë§¤ìš° íš¨ìœ¨ì ì…ë‹ˆë‹¤.

- ê·¸ë˜ì„œ Set, Dictionaryì˜ insertion, deletionì€ O(1)ì…ë‹ˆë‹¤.

â†’ Key ê°œìˆ˜ê°€ ë„ˆë¬´ ë§ì•„ì„œ, Hash ì¶©ëŒì´ ë‚œë‹¤ë©´? $_{(3)}$

â†’â†’ 1. Open access : open accessì—ëŠ” Linear probing, Quadratic probing, Double Hashing ê°™ì€ ë°©ë²•ë¡ ì´ ìˆìŠµë‹ˆë‹¤. ê³µí†µì ì€ ë¹ˆ í•´ì‹œ ê³µê°„ì„ ì–´ë–»ê²Œ ì°¾ì„ ê±´ê°€ì— ëŒ€í•œ ì´ì•¼ê¸°ì…ë‹ˆë‹¤. ì¦‰, í•´ì‹œ í…Œì´ë¸”ì€ ë’¤ì—ì„œ ë§í•  separate adressingì²˜ëŸ¼ ìƒˆë¡œìš´ ìë£Œêµ¬ì¡°ë¥¼ ë„£ì–´ì„œ ì¶©ëŒì„ íšŒí”¼í•˜ëŠ” êµ¬ì¡°ê°€ ì•„ë‹ˆë¼ í•˜ë‚˜ì˜ ë°°ì—´ì´ ìˆëŠ”ë° ì´ ë°°ì—´ì— ì •ë³´ë¥¼ ë°°ì •í•˜ëŠ”ë° ì–´ë–»ê²Œ í•˜ë©´ ì¶©ëŒì„ ìµœì†Œí™”í•˜ë©´ì„œ êµ¬í˜„í•  ê²ƒì¸ê°€ì— ë…¼ì˜ì…ë‹ˆë‹¤. 

ex) Linear probing: H + 1, H + 2, â€¦  ( mod(m) ) 

      Quadratic probing : H + 1^2, H + 2^2 + H + 3^2 ,  â€¦  ( mod (m) ) 

      Double Hashing :  h(k) + g(k), h(k) + 2(g) , â€¦  ( mod (m) ) 

ì—¬ê¸°ì„œ mì€ í•´ì‹œ í…Œì´ë¸”ì˜ ì‚¬ì´ì¦ˆì´ê³ , hì€ 1ì°¨ í•´ì‹œí•¨ìˆ˜, gëŠ” 2ì°¨ í•´ì‹œí•¨ìˆ˜ì…ë‹ˆë‹¤. 

      Linear probingë§Œ ì„¤ëª…í•˜ìë©´, ì£¼ì–´ì§„ í•´ì‹œì—ì„œ ì¶©ëŒì´ ì¼ì–´ë‚œë‹¤ë©´, ê·¸ê³³ì—ì„œë¶€í„° ê³„ì† ë¬´ì–¸ê°€ë¥¼ ë”í•´ì„œ ì°¾ì•„ë‚˜ê°€ëŠ” ê³¼ì •ì„ ì´ì•¼ê¸° í•©ë‹ˆë‹¤. (ê·¸ ë¬´ì–¸ê°€ê°€ ë‹¹ì—°íˆ í•¨ìˆ˜ë‚˜ ìŒìˆ˜, ì–‘ìˆ˜ê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 0ì´ ì•ˆë˜ëŠ” ì´ìœ ëŠ” ë¬´ì˜ë¯¸í•˜ê¸° ë•Œë¬¸ì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤. ë¬´í•œë²ˆ 0ì„ ë”í•´ë´ì•¼ ê°™ì€ í•´ì‹œê°’ì´ ë‚˜ì˜¤ë‹ˆê¹Œìš”.)

â†’â†’ 2. Separate  Adressing : ì£¼ì–´ì§„ hashë§ˆë‹¤ Linked-Listë“ , AVL tree ê°™ì€ ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•´ì„œ ê·¸ ì•ˆì— ì •ë³´ë¥¼ ë„£ì–´ ì¶©ëŒì„ ë°©ì§€í•˜ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤. 

### 3. Set:

Setì€ Hashë¥¼ ì´ìš©í•´ì„œ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ Hashableí•œ ê²ƒë“¤ë§Œ ë‹´ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 4. Dictionary

Dictionary ì—­ì‹œ Setì²˜ëŸ¼ Hashë¡œ êµ¬í˜„ë˜ì—ˆê¸° ë•Œë¬¸ì— Hashableí•˜ì§€ ì•Šì€ ê²ƒë“¤(List, set, dict ..)ì€ keyë¡œì„œ ì •ì˜ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 

â†’ ì›ƒê¸´ ê±´ classëŠ” hashableì´ë‹¤. Q : classê°€ ì™œ hashableí•œì§€ ìƒê°í•´ë´…ì‹œë‹¤. 

```python
>>> a = dict()
>>> a[tuple] = 0
>>> a[tuple()] = 1
>>> print(a)
>>> {<class 'tuple'>: 1, (): 1}
```

â†’ UnHashable : list, set, dict, bytearray

â†’ Hashable : int, float, complex, str, tuple, frozenset, __hash__()ì™€ __eq__()ë¥¼ êµ¬í˜„í•œ class instance. 

Q : True, False, Noneì€ Hashableí• ê¹Œìš”? 

### 5. ì„±ëŠ¥ ë¹„êµ ë¬¸ì œ: `List.pop(0)` vs `collections.deque.popleft()`

- **`List.pop(0)`ì˜ ì‹œê°„ ë³µì¡ë„:  O(n)**
    - **ì´ìœ **: ë¦¬ìŠ¤íŠ¸ëŠ” ì—°ì†ëœ ë©”ëª¨ë¦¬ ë¸”ë¡ì— ë°ì´í„°ë¥¼ ì €ì¥í•©ë‹ˆë‹¤. ë¦¬ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ ìš”ì†Œë¥¼ ì œê±°í•˜ë ¤ë©´, ë‚˜ë¨¸ì§€ ëª¨ë“  ìš”ì†Œë¥¼ í•œ ì¹¸ì”© ì•ìœ¼ë¡œ ì´ë™ì‹œì¼œì•¼ í•©ë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œ ëª¨ë“  ìš”ì†Œë¥¼ ì´ë™ì‹œí‚¤ëŠ” ë° ì‹œê°„ì´ ê±¸ë¦¬ë¯€ë¡œ, ì‹œê°„ ë³µì¡ë„ëŠ” ë¦¬ìŠ¤íŠ¸ì˜ ê¸¸ì´ì— ë¹„ë¡€í•˜ì—¬ O(n)ì´ ë©ë‹ˆë‹¤.
        
        
- **`collections.deque.popleft()`ì˜ ì‹œê°„ ë³µì¡ë„: O(1)**
    - **ì´ìœ **: `deque`ëŠ” ì–‘ë°©í–¥ íë¡œ, ì–‘ìª½ ëì—ì„œ ë¹ ë¥´ê²Œ ì‚½ì…ê³¼ ì‚­ì œê°€ ê°€ëŠ¥í•œ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ë‚´ë¶€ì ìœ¼ë¡œ `deque`ëŠ” ì—°ê²° ë¦¬ìŠ¤íŠ¸(ë˜ëŠ” ë°°ì—´ì˜ ë¸”ë¡)ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„ë˜ë©°, ì²« ë²ˆì§¸ ìš”ì†Œë¥¼ ì œê±°í•  ë•Œ ë‚˜ë¨¸ì§€ ìš”ì†Œë“¤ì„ ì´ë™ì‹œí‚¤ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤. ë”°ë¼ì„œ ì²« ë²ˆì§¸ ìš”ì†Œë¥¼ ì œê±°í•˜ëŠ” ì—°ì‚°ì€ ìƒìˆ˜ ì‹œê°„ì— ì´ë£¨ì–´ì§€ë©°, ì‹œê°„ ë³µì¡ë„ëŠ” O(1)ì…ë‹ˆë‹¤.

### ì„±ëŠ¥ ë¹„êµ: Listì™€ Setì˜ ì‚­ì œ ë° ì‚½ì… ì‹œê°„ ë³µì¡ë„

- **ë¦¬ìŠ¤íŠ¸(List)ì˜ ì‚­ì œ ë° ì‚½ì… ì‹œê°„ ë³µì¡ë„**
    - **ì‚­ì œ (`list.delete(index)`) ì‹œê°„ ë³µì¡ë„**: O(n)
        - **ì´ìœ **: ì•ì„œ ì–¸ê¸‰í–ˆë˜ ê²ƒì²˜ëŸ¼ ë¦¬ìŠ¤íŠ¸ì˜ íŠ¹ì • ìœ„ì¹˜ì—ì„œ ìš”ì†Œë¥¼ ì‚­ì œí•˜ë ¤ë©´, ê·¸ ì´í›„ì˜ ëª¨ë“  ìš”ì†Œë¥¼ í•œ ì¹¸ì”© ì•(í˜¹ì€ ë’¤)ìœ¼ë¡œ ì´ë™í•´ì•¼ í•˜ë¯€ë¡œ, ë¦¬ìŠ¤íŠ¸ì˜ ê¸¸ì´ì— ë¹„ë¡€í•œ ì‹œê°„ì´ ê±¸ë¦½ë‹ˆë‹¤.
    - **ì‚½ì… (`list.insert(index, value)`)**: **ì‹œê°„ ë³µì¡ë„**: O(n)
        - **ì´ìœ **: ë¦¬ìŠ¤íŠ¸ì˜ íŠ¹ì • ìœ„ì¹˜ì— ìš”ì†Œë¥¼ ì‚½ì…í•˜ë ¤ë©´, ê·¸ ì´í›„ì˜ ëª¨ë“  ìš”ì†Œë¥¼ í•œ ì¹¸ì”© ë’¤(í˜¹ì€ ì•)ë¡œ ë°€ì–´ì•¼ í•˜ë¯€ë¡œ, ë¦¬ìŠ¤íŠ¸ì˜ ê¸¸ì´ë§Œí¼ì˜ ì‹œê°„ì´ ê±¸ë¦½ë‹ˆë‹¤.
- **ì…‹(Set)ì˜ ì‚­ì œ ë° ì‚½ì… ì‹œê°„ ë³µì¡ë„**
    - **ì‚­ì œ (`set.remove(value)` ë˜ëŠ” `set.discard(value)`)**: **ì‹œê°„ ë³µì¡ë„**: O(1)
        - **ì´ìœ **: Setì€ í•´ì‹œ í…Œì´ë¸”ì„ ê¸°ë°˜ìœ¼ë¡œ êµ¬í˜„ë˜ë¯€ë¡œ, ìš”ì†Œì˜ ìœ„ì¹˜ë¥¼ í•´ì‹œ ê°’ìœ¼ë¡œ ë°”ë¡œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì‚­ì œ ì—°ì‚°ì€ ìƒìˆ˜ ì‹œê°„ì— ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.
    - **ì‚½ì… (`set.add(value)`)**: **ì‹œê°„ ë³µì¡ë„**: O(1)
        - **ì´ìœ **: Setì˜ ìš”ì†Œ ì‚½ì… ì—­ì‹œ í•´ì‹œ ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ ë°”ë¡œ ìœ„ì¹˜ë¥¼ ê²°ì •í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì‚½ì… ì—°ì‚°ë„ ìƒìˆ˜ ì‹œê°„ì— ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

### ê²°ë¡  : ì´ëŸ¬í•œ ì‹œê°„ë³µì¡ë„ì˜ ì°¨ì´ë¥¼ ì•Œê³  ìˆë‹¤ë©´, ìƒí™©ì— ë”°ë¼ ì ì ˆí•œ ìë£Œêµ¬ì¡°ë¥¼ ì„ íƒí•˜ì—¬ ì„±ëŠ¥ì„ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìì„¸í•œ ê±´ ìë£Œ (3)ì„ ì°¸ê³ í•˜ì‹œê¸¸ ë°”ëë‹ˆë‹¤.

- List & Set : Time Complexity of Deletion and Insertion $_{(2)}$
    
    
    |  | Set | List | Dictionary |
    | --- | --- | --- | --- |
    | Deletion | O(1) | O(n) | O(1) |
    | Insertion | O(1) | O(n) | O(1) |

### 6.  List Slicing

iterable, íŒŒì´ì¬ì—ì„œ ì¸ë±ì‹± ì ‘ê·¼ì´ ê°€ëŠ¥í•œ ìë£Œí˜•ì€ .__**getitem**__ë¥¼ ì´ìš©í•œ iterable ê°ì²´ì…ë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šì€ ê°ì²´ëŠ” __*.***iter**__ ì„ ì“°ëŠ” subscriptable ê°ì²´ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ ë§í•˜ëŠ” Slicing(subscritable ê°ì²´ì˜ ì¸ë±ìŠ¤ ì ‘ê·¼)ì€ ë‹¹ì—°íˆ .__getitem__ì„ ì“°ëŠ” iterable ê°ì²´ì— ëŒ€í•œ ë‚´ìš©ì…ë‹ˆë‹¤. 

ğŸ’¡Â iterable ê°ì²´ì™€ subscripptable ê°ì²´ì˜ ê³µí†µì ì´ ë­˜ê¹Œ? 

```python
a = set([1,2,3])
b = dict(zip([1,2,3],[1,1,1]))
print(
for num in a:
	print(num)
	
for num in b:
	print(num) # 1, 2, 3 
```

ğŸ’¡Â iterable ê°ì²´ì™€ subscriptable ê°ì²´ë¥¼ ì–´ë–»ê²Œ í™•ì¸í•  ìˆ˜ ìˆì„ê¹Œ?

```python
import collections.abc as abc

a = [1,2,3]
b = dict(zip([1,2,3],[1,1,1]))

# Iterable Check
print(isinstance(a, abc.Iterable)) # True
print(isinstance(b, abc.Iterable)) # True

# Subscriptable Check
print(isinstance(a, abc.Sequence)) # True
print(isinstance(b, abc.Sequence)) # False
```

List Slicingì€ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 

ë¨¼ì € Listê°€ subscriptableí•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ¬í•œ instanceì˜ ì´ë¦„ì„ iterable_instanceë¼ê³  í•œë‹¤ë©´, ì•„ë˜ì™€ ê°™ì´ ë¦¬ìŠ¤íŠ¸ ìŠ¬ë¼ì´ì‹±ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 

```python
iterable_instance = [i for _ in range(1,103)] 

iterable_instance[start_index:end_index:step]  # [start_index, end_index)

# [start_index, start_index + step, start_index + step + step, ... , end_index)
```

ğŸ’¡Â ìì£¼ ì“¸ ë¬¸ë²• : 

1. ë’¤ì§‘ê¸° 
    
    ```python
    a = [1,2,3] 
    a = [::-1] # 3, 2, 1
    ```
    

  

### ğŸ”” Reference :

     1. https://cs.stackexchange.com/questions/108958/the-origin-of-list-data-structure

     2. https://wiki.python.org/moin/TimeComplexity

     3. https://en.wikipedia.org/wiki/Hash_collision

## Problems

---

Problem 1.

```python
# 1. using Counter or Dictionary 

# O(nlogn)
from collections import Counter 
def remove_duplicates_and_sort(lst):
		a = Counter(lst)
		return sorted(a.keys())

# O(nlogn)
from collections import defaultdict
def remove_duplicates_and_sort(lst):
		a = defaultdict(int)
		for num in lst:
				if a.get(num,0) == 0:
						a[num]+=1
						
		return sorted(a.keys())	

# 2. using Set 
# O(nlogn)
def remove_duplicates_and_sort(lst):
	  return sorted(list(set(lst))) 

# or 
# O(nlogn)
def remove_duplicates_and_sort(lst):
    ret = []
    tmp_set = set()
    for num in lst:
        if tmp_set.intersection({num}) == set(): 
            tmp_set.add(num)
            ret.append(num)
    return sorted(ret)
 

# 3. using (monotone) stack or queue or deque 
# O(nlogn)
def remove_duplicates_and_sort(lst):
		
		lst.sort() # 1,2,2, ,, .. . . , 3,4,4,5
		st = [lst[0]] 
		n = len(lst)
		for idx in range(1, n):
				if st[-1] < lst[idx]:
						st.append(lst[idx])
		
		return st
		
# from 3. upgrade using local max value after sorting 
# in fact, same idea with monotone stack 
# O(nlogn)
def remove_duplicates_and_sort(lst):
    lst.sort()
    m = -float('inf')
    ret = [] 
    for num in lst:
        if m < num: 
            m = num
            ret.append(m) 
    return ret
```

Problem 2.

```python
from collections import Counter

def count_word_frequencies(words):
		
		return sorted((words).items(), key=lambda x : x[0])

print(count_word_frequencies(['b','c','c','d','a','a']))
# output : [('a', 2), ('b', 1), ('c', 2), ('d', 1)]

```

Problem 3.

```python
def key_exists(d:dict,key):
		if d.get(key,0) == 0:
				return False
		return True

```

Problem 4: sum of all elements of tuple

```python

def sum_of_tuple(tpl):
		return sum(tpl)

```

Problem 5: 

```python
def slice_list(lst, start, end):
		return lst[start:end] # [start,end)
		
```
