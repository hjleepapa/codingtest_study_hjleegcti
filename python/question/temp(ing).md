
# 1. 리스트의 기본 개념
리스트는 파이썬에서 가장 많이 사용되는 데이터 구조 중 하나로, 여러 개의 데이터를 순차적으로 저장할 수 있는 가변 길이 배열입니다. 리스트는 대괄호 `[]`를 사용해 정의하며, 각 원소는 쉼표 `,`로 구분됩니다. 리스트는 다양한 데이터 타입을 혼합해서 저장할 수 있으며, 인덱스를 통해 개별 요소에 접근할 수 있습니다.


## 1.1 리스트 초기화 방법

리스트를 초기화하는 여러 방법을 살펴보겠습니다.

### 정수만 있는 리스트
```python
# 정수 리스트 예제
int_list = [1, 2, 3, 4, 5]
print(int_list[0])  # 첫 번째 요소에 접근 -> 1
print(int_list[-1])  # 마지막 요소에 접근 -> 5
```

### 문자열만 있는 리스트
```python
# 문자열 리스트 예제
str_list = ['apple', 'banana', 'cherry']
print(str_list[0])  # 첫 번째 요소에 접근 -> 'apple'
print(str_list[-1])  # 마지막 요소에 접근 -> 'cherry'
```

### 빈 리스트 초기화
```python
# 빈 리스트 예제
empty_list = []
print(empty_list)  # 빈 리스트 출력 -> []
```

### 리스트 컴프리헨션을 사용한 초기화
```python
# 리스트 컴프리헨션 예제
squares = [x ** 2 for x in range(5)]
print(squares)  # 제곱수를 가진 리스트 -> [0, 1, 4, 9, 16]
```

# 2. 리스트의 효율성

| 메서드명   | 동작                               | 리턴값           | 시간 복잡도   | 비고                                                 |
|:-----------|:-----------------------------------|:-----------------|:--------------|:-----------------------------------------------------|
| append()   | 리스트의 마지막에 원소를 추가      | None             | O(1)          |                                                      |
| insert()   | 리스트의 특정 위치에 원소를 삽입   | None             | O(n)          | 삽입 위치 이후의 모든 요소를 이동해야 함             |
| pop()      | 리스트의 마지막 원소를 제거        | 제거된 원소      | O(1)          |                                                      |
| pop(i)     | 리스트의 i번째 원소를 제거         | 제거된 원소      | O(n)          | i번째 원소를 제거한 후 i 이후의 요소들을 이동해야 함 |
| remove()   | 리스트에서 특정 원소를 제거        | None             | O(n)          | 제거할 원소를 찾기 위해 선형 탐색이 필요함           |
| index()    | 리스트에서 특정 값의 인덱스를 반환 | 찾은 값의 인덱스 | O(n)          | 찾으려는 값의 위치를 선형 탐색으로 찾음              |

## 2.1  리스트 메서드 시간 복잡도
```python
# append() - 리스트의 마지막에 원소 추가
my_list = [1, 2, 3]
my_list.append(4)  # O(1)
print(my_list)  # [1, 2, 3, 4]

# insert() - 리스트의 특정 위치에 원소 삽입
my_list.insert(1, 1.5)  # O(n)
print(my_list)  # [1, 1.5, 2, 3, 4]

#  pop() - 리스트의 마지막 원소 제거
```python
removed_item = my_list.pop()  # O(1)
print(removed_item)  # 4
print(my_list)  # [1, 1.5, 2, 3]

#  pop(1) - 리스트의 두 번째 원소 제거
removed_second_item = my_list.pop(1)  # O(n)
print(removed_second_item)  # 1.5
print(my_list)  # [1, 2, 3]

# remove() - 리스트에서 특정 원소 제거
my_list.remove(2)  # O(n)
print(my_list)  # [3]

# index() - 리스트에서 특정 값의 인덱스 반환
index_of_three = my_list.index(3)  # O(n)
print(index_of_three)  # 0
```


# 3. 튜플

## 3.1 튜플의 개념과 리스트와의 차이점 
튜플은 리스트와 유사하지만, 한 번 정의되면 변경할 수 없는 불변(immutable) 데이터 구조입니다. 튜플은 소괄호 `()`를 사용해 정의하며, 리스트와 달리 데이터를 변경, 추가, 삭제할 수 없습니다.

```python
# 튜플 예제
my_tuple = (1, 2, 3)
# my_tuple[0] = 0  # 튜플은 불변이므로 값을 변경할 수 없습니다. 이 줄은 에러를 발생시킵니다.
print(my_tuple[1])  # 인덱스를 사용하여 접근 -> 2
```

## 3.2 튜플 사용이 적합한 경우 
튜플은 데이터의 변경이 필요 없고, 고정된 데이터 집합을 표현할 때 적합합니다. 예를 들어, 함수의 반환값을 여러 개 반환하고자 할 때 튜플을 자주 사용합니다.

```python
# 튜플을 사용하는 함수 반환 예제
def get_coordinates():
    return (10, 20)  # (x, y) 좌표를 튜플로 반환

coords = get_coordinates()
print(coords)  # (10, 20)
```

## 3.3 튜플 메서드의 시간 복잡도

튜플은 불변 객체이므로 제공되는 메서드는 제한적입니다. 아래는 튜플의 주요 메서드와 그 시간 복잡도에 대한 설명 및 예시입니다.

| 메서드명   | 동작                               | 리턴값           | 시간 복잡도   | 비고                                                 |
|------------|------------------------------------|------------------|---------------|------------------------------------------------------|
| `count()`  | 튜플 내 특정 값의 개수를 셉니다.  | 정수             | O(n)          | n은 튜플의 길이. 전체를 순회해야 하기 때문에 O(n)입니다. |
| `index()`  | 튜플 내 특정 값의 첫 번째 위치를 반환합니다. | 정수      | O(n)          | n은 튜플의 길이. 값을 찾을 때까지 순회해야 합니다.        |
| `len()` | 튜플의 길이를 반환합니다.         | 정수             | O(1)          | 길이를 구하는 것은 상수 시간 내에 처리됩니다.                |
| `getitem()` | 인덱스를 사용해 요소에 접근합니다. | 해당 요소       | O(1)          | 인덱스로 접근하는 것은 상수 시간 내에 처리됩니다.            |
| `contains()` | 튜플에 특정 값이 포함되어 있는지 확인합니다. | 불리언        | O(n)          | n은 튜플의 길이. 값이 존재하는지 확인하기 위해 순회합니다.    |

### 메서드 예시

```python
my_tuple = (1, 2, 3, 4, 2)

# count()
print(my_tuple.count(2))  # 출력: 2

# index()
print(my_tuple.index(3))  # 출력: 2

# __len__()
print(len(my_tuple))  # 출력: 5

# __getitem__()
print(my_tuple[1])  # 출력: 2

# __contains__()
print(my_tuple.__contains__(3))  # 출력: True
print(my_tuple.__contains__(5))  # 출력: False
```



# 4. 셋(Set)

## 4.1 셋의 개념과 특징
셋은 중복된 데이터를 허용하지 않는 데이터 구조로, 데이터의 순서가 중요하지 않은 경우에 사용됩니다. 셋은 중괄호 `{}`를 사용해 정의하며, 각 요소는 고유해야 합니다.

```python
# 셋 예제
my_set = {1, 2, 2, 3, 4}  # 2가 두 번 들어가 있지만, 중복은 제거됩니다.
print(my_set)  # {1, 2, 3, 4}
```

## 4.2 셋과 리스트의 차이점
셋은 중복된 값을 허용하지 않으며, 데이터의 순서가 중요하지 않습니다. 반면 리스트는 중복된 값을 허용하며, 데이터의 순서가 중요합니다.

```python
# 리스트와 셋의 차이점 예제
my_list = [1, 2, 2, 3, 4]
my_set = set(my_list)  # 리스트를 셋으로 변환하면 중복이 제거됩니다.
print(my_list)  # [1, 2, 2, 3, 4]
print(my_set)   # {1, 2, 3, 4}
```

## 4.3 셋 메서드의 시간 복잡도

셋은 해시 테이블로 구현되어 있어 대부분의 작업이 매우 빠르게 수행됩니다. 아래는 셋의 주요 메서드와 그 시간 복잡도에 대한 설명 및 예시입니다.

| 메서드명   | 동작                               | 리턴값           | 시간 복잡도   | 비고                                                 |
|------------|------------------------------------|------------------|---------------|------------------------------------------------------|
| `add()`    | 셋에 요소를 추가합니다.           | 없음             | O(1)          | 요소가 이미 존재하는 경우, 아무 변화도 일어나지 않습니다. |
| `remove()` | 셋에서 특정 요소를 제거합니다.    | 없음             | O(1)          | 요소가 없을 경우 `KeyError`를 발생시킵니다.            |
| `discard()`| 셋에서 특정 요소를 제거합니다.    | 없음             | O(1)          | 요소가 없어도 에러를 발생시키지 않습니다.               |
| `pop()`    | 셋에서 임의의 요소를 제거하고 반환합니다. | 해당 요소       | O(1)          | 셋이 비어 있으면 `KeyError`를 발생시킵니다.            |
| `clear()`  | 셋의 모든 요소를 제거합니다.      | 없음             | O(1)          | 모든 요소를 제거하여 빈 셋으로 만듭니다.               |
| `__contains__()` | 셋에 특정 값이 포함되어 있는지 확인합니다. | 불리언        | O(1)          | 특정 값이 셋에 있는지 확인합니다.                      |

### 메서드 예시

```python
my_set = {1, 2, 3, 4}

# add()
my_set.add(5)
print(my_set)  # 출력: {1, 2, 3, 4, 5}

# remove()
my_set.remove(2)
print(my_set)  # 출력: {1, 3, 4, 5}

# discard()
my_set.discard(3)
print(my_set)  # 출력: {1, 4, 5}

# pop()
popped_element = my_set.pop()
print(popped_element)  # 출력: 1 (임의의 요소)
print(my_set)  # 출력: {4, 5}

# clear()
my_set.clear()
print(my_set)  # 출력: set()

# __contains__()
print(4 in my_set)  # 출력: False
```



# 5. 딕셔너리
## 5.1 딕셔너리의 개념
딕셔너리는 키-값 쌍으로 이루어진 데이터 구조로, 각 키는 고유하며, 이를 통해 값을 빠르게 검색할 수 있습니다. 딕셔너리는 중괄호 `{}`를 사용해 정의합니다.

```python
# 딕셔너리 예제
my_dict = {'name': 'Alice', 'age': 25}
print(my_dict['name'])  # 키를 사용해 값에 접근 -> 'Alice'
```

## 5.2 딕셔너리 키로 사용될 수 있는 데이터 타입과 이유
딕셔너리의 키로 사용될 수 있는 데이터 타입은 변경 가능한(immutable) 타입이어야 합니다. 이는 키가 변경될 수 없어야 딕셔너리가 내부적으로 데이터를 효율적으로 관리할 수 있기 때문입니다. 따라서 문자열, 숫자, 튜플 등이 키로 사용될 수 있습니다.

```python
# 딕셔너리 키로 사용될 수 있는 데이터 타입 예제
valid_dict = {(1, 2): 'Tuple as key', 'name': 'String as key'}  # 튜플과 문자열이 키로 사용됨
print(valid_dict[(1, 2)])  # 'Tuple as key'
```

## 5.3 딕셔너리에서 키-값 쌍의 삽입
딕셔너리에서 키-값 쌍을 삽입하거나 삭제하는 연산의 시간 복잡도는 평균적으로 O(1)입니다.

```python
# 딕셔너리 삽입, 삭제 시간 복잡도 예제
my_dict['location'] = 'Wonderland'  # 삽입 -> O(1)
del my_dict['age']  # 삭제 -> O(1)
print(my_dict)  # {'name': 'Alice', 'location': 'Wonderland'}
```

## 5.4 리스트를 딕셔너리 키로 사용할 때 발생하는 오류 예제
리스트는 변경 가능한 데이터 타입이기 때문에 딕셔너리의 키로 사용할 수 없습니다. 만약 리스트를 키로 사용하려 하면 `TypeError`가 발생합니다.

```python
# 리스트를 딕셔너리 키로 사용하려 할 때 발생하는 오류 예제
try:
    invalid_dict = {[1, 2]: 'List as key'}
except TypeError as e:
    print(f"오류 발생: {e}")
```

## 5.4 딕셔너리의 효율성
  
| **메서드명** | **동작** | **리턴값** | **시간 복잡도** | **비고** |
|--------------|----------|------------|-----------------|----------|
| `get(key, default)` | 주어진 키에 대응하는 값을 반환하며, 키가 존재하지 않으면 `default` 값을 반환 | 해당 키의 값 또는 `default` 값 | O(1) | 키가 없을 때도 오류를 발생시키지 않음 |
| `keys()` | 딕셔너리의 모든 키를 반환 | 딕셔너리의 키들을 담은 뷰 객체 | O(1) | - |
| `values()` | 딕셔너리의 모든 값을 반환 | 딕셔너리의 값들을 담은 뷰 객체 | O(1) | - |
| `items()` | 딕셔너리의 키-값 쌍을 튜플 형태로 반환 | 딕셔너리의 (키, 값) 쌍을 담은 뷰 객체 | O(1) | - |
| `pop(key)` | 주어진 키에 대응하는 값을 반환하고, 해당 키-값 쌍을 딕셔너리에서 삭제 | 해당 키의 값 | O(1) | 키가 존재하지 않으면 `KeyError` 발생 |


```python
# 딕셔너리 메서드 사용 예제
sample_dict = {'fruit': 'apple', 'color': 'red', 'quantity': 10}

# get 메서드 사용
print(sample_dict.get('fruit'))  # 'apple'
print(sample_dict.get('price', 'Not Found'))  # 'Not Found'

# keys, values, items 메서드 사용
print(sample_dict.keys())    # dict_keys(['fruit', 'color', 'quantity'])
print(sample_dict.values())  # dict_values(['apple', 'red', 10])
print(sample_dict.items())   # dict_items([('fruit', 'apple'), ('color', 'red'), ('quantity', 10)])

# pop 메서드 사용
sample_dict.pop('quantity')
print(sample_dict)  # {'fruit': 'apple', 'color': 'red'}
```


## 6. 성능 비교 문제

### 6.1 리스트에서 `pop(0)`과 `collections.deque.popleft()`의 동작 방식과 성능 차이

- **리스트의 `pop(0)`**:
  - 리스트는 동적 배열로 구현되어 있습니다. `pop(0)`은 리스트의 첫 번째 요소를 제거하고 반환합니다.
  - 이 작업은 나머지 모든 요소를 왼쪽으로 한 칸씩 이동시켜야 하므로 시간 복잡도는 O(n)입니다.
  
- **`collections.deque`의 `popleft()`**:
  - `deque`는 양방향 큐로, 양쪽 끝에서의 삽입과 삭제가 O(1) 시간 내에 이루어집니다.
  - `popleft()`는 첫 번째 요소를 제거하고 반환하며, 요소 이동이 필요 없으므로 시간 복잡도는 O(1)입니다.

- **성능 차이**:
  - 리스트의 `pop(0)`은 모든 요소를 이동시켜야 하기 때문에 시간이 많이 소요됩니다.
  - 반면 `deque.popleft()`는 바로 첫 번째 요소를 제거하므로 훨씬 효율적입니다.
  - 큰 데이터셋에서 첫 번째 요소를 자주 제거하는 작업이 필요하다면 `deque`를 사용하는 것이 좋습니다.

### 6.2 리스트와 셋(Set)에서의 데이터 추가 및 삭제의 시간 복잡도 비교

- **리스트**:
  - **추가**: 리스트 끝에 요소를 추가하는 것은 평균적으로 O(1)입니다. 그러나 리스트 크기 조정이 필요하면 O(n)까지 걸릴 수 있습니다.
  - **삭제**: 리스트에서 요소를 삭제하는 것은 최악의 경우 O(n)입니다. 특히, 요소를 찾고 삭제하는 과정이 필요하면 더 느려질 수 있습니다.

- **셋(Set)**:
  - **추가**: 셋은 해시 테이블로 구현되어 있으며, 요소를 추가하는 데 평균적으로 O(1)의 시간이 걸립니다.
  - **삭제**: 셋에서 요소를 삭제하는 것도 평균적으로 O(1)입니다.

### 6.3 고유한 값을 찾을 때 리스트와 셋(Set)의 비교

- **리스트**:
  - 리스트에서 고유한 값을 찾으려면 모든 요소를 순회하며 비교해야 합니다. 이 작업의 시간 복잡도는 O(n^2)입니다.
  - 리스트는 중복을 허용하기 때문에 고유한 값을 찾기 위해서는 추가적인 작업이 필요합니다.

- **셋(Set)**:
  - 셋은 기본적으로 고유한 값을 저장하는 컬렉션입니다. 중복된 값을 자동으로 제거합니다.
  - 주어진 데이터에서 고유한 값을 찾을 때 셋을 사용하는 것이 효율적입니다. 이 작업의 시간 복잡도는 O(n)입니다.
  - 따라서, 고유한 값을 찾아야 할 때는 리스트보다 셋을 사용하는 것이 훨씬 빠르고 효율적입니다.

## 7. 리스트 슬라이싱

### 7.1 리스트 슬라이싱이란?

- **리스트 슬라이싱**은 파이썬에서 리스트의 부분 배열을 쉽게 추출하는 방법입니다. 슬라이싱은 리스트의 특정 부분을 선택하여 새로운 리스트를 생성합니다.

### 7.2 리스트 슬라이싱의 문법과 예제

- **문법**: `list[start:stop:step]`
  - `start`: 슬라이싱이 시작되는 인덱스 (이 값을 포함).
  - `stop`: 슬라이싱이 끝나는 인덱스 (이 값을 포함하지 않음).
  - `step`: 슬라이싱의 간격 (생략 가능).

- **예제**:
  ```python
  my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

  # 2번 인덱스부터 5번 인덱스까지 (5번 인덱스는 포함하지 않음)
  sub_list = my_list[2:5]  # 결과: [2, 3, 4]

  # 리스트의 처음부터 6번 인덱스까지 (6번 인덱스는 포함하지 않음)
  sub_list = my_list[:6]  # 결과: [0, 1, 2, 3, 4, 5]

  # 3번 인덱스부터 끝까지
  sub_list = my_list[3:]  # 결과: [3, 4, 5, 6, 7, 8, 9]

  # 리스트의 모든 요소를 2칸 간격으로 선택
  sub_list = my_list[::2]  # 결과: [0, 2, 4, 6, 8]

  # 리스트를 역순으로 정렬
  sub_list = my_list[::-1]  # 결과: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
  ```

- **특징**:
  - 슬라이싱 결과는 원본 리스트와는 별개의 새로운 리스트입니다.
  - 인덱스가 범위를 벗어나더라도 에러가 발생하지 않고, 가능한 범위 내에서 최대한의 값을 반환합니다.



# 코딩 문제 및 해결

## 문제 1: 리스트의 중복 제거 및 정렬

리스트 `lst`가 주어졌을 때, 리스트 내 중복된 요소를 제거하고 남은 요소들을 오름차순으로 정렬한 새로운 리스트를 반환하는 함수를 작성하세요.

### 해결 방법

```python
def remove_duplicates_and_sort(lst):
    return sorted(set(lst))

# 예시
print(remove_duplicates_and_sort([4, 2, 2, 1, 3, 4]))  # 출력: [1, 2, 3, 4]
print(remove_duplicates_and_sort([5, 5, 5, 5]))  # 출력: [5]
print(remove_duplicates_and_sort([1, 2, 3, 4, 5]))  # 출력: [1, 2, 3, 4, 5]
```

## 문제 2: 딕셔너리 키의 빈도수 계산

문자열 리스트 `words`가 주어졌을 때, 각 단어가 리스트에 등장하는 빈도수를 딕셔너리로 반환하는 함수를 작성하세요.

### 해결 방법

```python
def count_word_frequencies(words):
    frequency_dict = {}
    for word in words:
        if word in frequency_dict:
            frequency_dict[word] += 1
        else:
            frequency_dict[word] = 1
    return frequency_dict

# 예시
print(count_word_frequencies(["apple", "banana", "apple", "orange", "banana", "apple"]))  
# 출력: {'apple': 3, 'banana': 2, 'orange': 1}
print(count_word_frequencies(["dog", "cat", "dog", "dog", "fish"]))  
# 출력: {'dog': 3, 'cat': 1, 'fish': 1}
```

## 문제 3: 딕셔너리 키 존재 여부 확인

딕셔너리 `d`와 키 `key`가 주어졌을 때, 해당 키가 딕셔너리에 존재하는지 여부를 반환하는 함수를 작성하세요.

### 해결 방법

```python
def key_exists(d, key):
    return key in d

# 예시
print(key_exists({"name": "Alice", "age": 25}, "name"))  # 출력: True
print(key_exists({"name": "Alice", "age": 25}, "address"))  # 출력: False
print(key_exists({}, "key"))  # 출력: False
```

## 문제 4: 튜플의 요소 합

튜플 `tpl`이 주어졌을 때, 튜플 내 모든 요소의 합을 반환하는 함수를 작성하세요.

### 해결 방법

```python
def sum_of_tuple(tpl):
    return sum(tpl)

# 예시
print(sum_of_tuple((1, 2, 3, 4)))  # 출력: 10
print(sum_of_tuple((5,)))  # 출력: 5
print(sum_of_tuple(()))  # 출력: 0
```

## 문제 5: 리스트 슬라이싱으로 부분 리스트 추출

리스트 `lst`와 두 개의 정수 `start`, `end`가 주어졌을 때, 주어진 범위에 해당하는 부분 리스트를 반환하는 함수를 작성하세요. `start` 인덱스는 포함되며, `end` 인덱스는 포함되지 않습니다.

### 해결 방법

```python
def slice_list(lst, start, end):
    return lst[start:end]

# 예시
print(slice_list([10, 20, 30, 40, 50], 1, 3))  # 출력: [20, 30]
print(slice_list([1, 2, 3, 4, 5], 0, 5))  # 출력: [1, 2, 3, 4, 5]
print(slice_list([7, 8, 9], 1, 1))  # 출력: []
```



